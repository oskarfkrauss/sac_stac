# AUTOGENERATED! DO NOT EDIT! File to edit: 02A_spot.ipynb (unless otherwise specified).

__all__ = ['prep_spot', 'spot_get_dt', 'spot_parsemeta', 'spot_get_crs', 'spot_get_geom', 'spot_get_bbox',
           'spot_get_gsd', 'spot_get_cloudcover', 'spot_create_item', 'spot_bands', 'spot_band_refs',
           'spot_find_band_path', 'spot_add_assets2item', 'spot_create_collection']

# Cell
import os
from glob import glob
import time
import numpy as np
from datetime import datetime
import json

import xmltodict
import pystac
from pystac import STAC_IO
from pystac.extensions.eo import Band
import geopandas as gpd

from .utils import sedas_client, sedas_find_datasets, sedas_download, sedas_extract
from .utils import cogmosaicbands
from .utils import s3_upload_dir, s3_list_objects_paths, clean_up
from .utils import pystac_setIO, create_uri

# Cell
def prep_spot(sedas_supplierId, inter_dir="/tmp/data/intermediate/",
                  s3_bucket="public-eo-data", s3_dir="uksa-ssgp/spot/"):
    try:
        inter_dir = f"{inter_dir}{sedas_supplierId}_tmp/"
        os.makedirs(inter_dir, exist_ok=True)
        scene_name = sedas_supplierId
        down_zip = f"{inter_dir}{scene_name}.zip"
        scene_dir = f"{down_zip[:-4]}/"
        print(f"{time.strftime('%Y-%m-%d %H:%M:%S')} Preparing {scene_name} within {inter_dir}")
        # find & download
        sedas_scene_res = sedas_client().search_product(sedas_supplierId)[0]
        sedas_download([sedas_scene_res], inter_dir)
        sedas_extract(down_zip, scene_dir)
        # sensor-specific band mosaicing and cogifying
        imgs_ms = glob(f"{scene_dir}*/*/*MS_001*/*.TIF")
        imgs_pan = glob(f"{scene_dir}*/*/*P_001*/*.TIF")
        cogmosaicbands(imgs_pan, 1, imgs_pan[0][:-20])
        cogmosaicbands(imgs_ms, 4, imgs_ms[0][:-20])
        # upload
        s3_upload_dir(scene_dir, s3_bucket, s3_dir)
        print(f"{time.strftime('%Y-%m-%d %H:%M:%S')} Prepared {scene_name} at {s3_dir}{scene_name}/")
        clean_up(inter_dir)
    except Exception as e:
        print(f"{time.strftime('%Y-%m-%d %H:%M:%S')} Failed with {e}")
        clean_up(inter_dir)

# Cell
pystac_setIO()

# Cell
def spot_get_dt(scene_name):
    return datetime.strptime(scene_name.split('_')[5][:14], '%Y%m%d%H%M%S')

# Cell
def spot_parsemeta(scene_name, scene_obj_paths):
    meta_path = [i for i in scene_obj_paths if (i.endswith('.XML')) & (os.path.basename(i).startswith('DIM'))][0]
    return xmltodict.parse(pystac.STAC_IO.read_text(create_uri(meta_path)))

# Cell
def spot_get_crs(metadata):
    return int(metadata['Dimap_Document']['Coordinate_Reference_System']['Projected_CRS']['PROJECTED_CRS_NAME'][:5])

# Cell
def spot_get_geom(scene_paths, native_epsg):
    nat_crs = {"init": f"epsg:{native_epsg}"}
    roi_path = [i for i in scene_paths if (i.endswith('1_MSK.GML') * os.path.basename(i).startswith('ROI'))][0]
    roi_uri = create_uri(roi_path)
    g = gpd.read_file(roi_uri)
    g.crs = f"EPSG:{native_epsg}"
    return json.loads(g.to_crs('EPSG:4326').to_json(show_bbox=True))['features'][0]['geometry']

# Cell
def spot_get_bbox(metadata):
    lons = [float(i['LON']) for i in metadata['Dimap_Document']['Dataset_Content']['Dataset_Extent']['Vertex']]
    lats = [float(i['LAT']) for i in metadata['Dimap_Document']['Dataset_Content']['Dataset_Extent']['Vertex']]
    return [min(lons), min(lats), max(lons), max(lats)]

# Cell
def spot_get_gsd(metadata):
    across = float(metadata['Dimap_Document']['Geometric_Data']['Use_Area']['Located_Geometric_Values'][0]['Ground_Sample_Distance']['GSD_ACROSS_TRACK'])
    along = float(metadata['Dimap_Document']['Geometric_Data']['Use_Area']['Located_Geometric_Values'][0]['Ground_Sample_Distance']['GSD_ALONG_TRACK'])
    return round(( across + along ) / 2, 2)

# Cell
def spot_get_cloudcover(metadata):
    return round(float(metadata['Dimap_Document']['Dataset_Content']['CLOUD_COVERAGE']['#text']),2)

# Cell
def spot_create_item(scene_name, scene_obj_paths):

    meta = spot_parsemeta(scene_name, scene_obj_paths)

    crs = spot_get_crs(meta)

    item = pystac.Item(id=scene_name,
                      datetime=spot_get_dt(scene_name),
                      geometry=spot_get_geom(scene_obj_paths, crs),
                      bbox=spot_get_bbox(meta),
                      properties={})

    item.common_metadata.gsd = spot_get_gsd(meta)

    item.ext.enable('eo')
    item.ext.eo.cloud_cover = spot_get_cloudcover(meta)

    item.ext.enable('projection')
    item.ext.projection.epsg = spot_get_crs(meta)

    return item

# Cell
spot_bands = [Band.create(name='Panchromatic', description='Panchromatic: 450 - 745 nm', common_name='pan'),
              Band.create(name='Blue', description='Blue: 450 - 520 nm', common_name='blue'),
              Band.create(name='Green', description='Green: 530 - 590 nm', common_name='green'),
              Band.create(name='Red', description='Red: 625 - 695 nm', common_name='red'),
              Band.create(name='Near-Infrared', description='Near-Infrared: 760 - 890 nm', common_name='nir')]

# Cell
spot_band_refs = {
    'Panchromatic':{'ends':'_band1', 'dif':'_P_', 'id':'B0'},
    'Blue':{'ends':'_band1', 'dif':'_MS_', 'id':'B1'},
    'Green':{'ends':'_band2', 'dif':'_MS_', 'id':'B2'},
    'Red':{'ends':'_band3', 'dif':'_MS_', 'id':'B3'},
    'Near-Infrared':{'ends':'_band4', 'dif':'_MS_', 'id':'B4'}
}

# Cell
def spot_find_band_path(band_name, scene_obj_paths):
    matched_paths = [ o for o in scene_obj_paths if (o.endswith(f"{spot_band_refs[band_name]['ends']}.tif")) & (f"{spot_band_refs[band_name]['dif']}" in o) ]
    if len(matched_paths) > 1:
        raise Exception(f"Found too many matches: {matched_paths}")
#     elif len(matched_paths) == 0: # should probably add something for when no asset is found...
#         raise Warning(f"")
    return matched_paths[0]

# Cell
def spot_add_assets2item(item, scene_obj_paths):
    for band in spot_bands:
#         print(band.name)

        band_path = spot_find_band_path(band.name, scene_obj_paths)
        band_url = create_uri(band_path)
#         print(band_url)

        asset = pystac.Asset(href=band_url, media_type=pystac.MediaType.COG)
        item.ext.eo.set_bands([band], asset)
        item.add_asset(spot_band_refs[band.name]['id'], asset)

    return item

# Cell
def spot_create_collection(spot_dir, bucket='public-eo-data'):

    collection_id = 'uksa-ssgp-spot'
    collection_title = 'SSGP-procured Spot 6 & 7 images over the UK'
    collection_description = '''### UKSA / SSGP SPOT 6 & 7

    A collection of SPOT 6 & 7 images over the UK. Procured by UKSA under its Space for Smarter Government Programme (SSGP).
    '''

    # initially arbitrary as updated later
    spatial_extent = pystac.SpatialExtent([[-7.57216793459, 49.959999905, 1.68153079591, 58.6350001085]])
    temporal_extent = pystac.TemporalExtent([[datetime(2011, 12, 16), None]])
    collection_extent = pystac.Extent(spatial_extent, temporal_extent)

    collection = pystac.Collection(id=collection_id,
                                   title=collection_title,
                                   description=collection_description,
                                   extent=collection_extent)

    collection.providers = [
        pystac.Provider(name='Airbus Defence & Space', roles=['producer'], url='https://www.airbus.com/space.html'),
        pystac.Provider(name='UK Space Agency', roles=['licensor'], url='https://www.gov.uk/government/organisations/uk-space-agency'),
        pystac.Provider(name='Satellite Applications Catapult', roles=['processor'], url='https://sa.catapult.org.uk/'),
        pystac.Provider(name='Satellite Applications Catapult', roles=['host'], url='https://sa.catapult.org.uk/')
    ]

    obj_paths_list = s3_list_objects_paths(bucket, spot_dir)
    scene_names = list(np.unique([ i.split('/')[2] for i in obj_paths_list ]))

    for scene_name in scene_names:

        scene_obj_paths = [ i for i in obj_paths_list if scene_name in i]

        item = spot_create_item(scene_name, scene_obj_paths)
        item = spot_add_assets2item(item, scene_obj_paths)

        collection.add_item(item)

    collection.update_extent_from_items()

    return collection
