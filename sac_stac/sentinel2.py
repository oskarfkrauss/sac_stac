# AUTOGENERATED! DO NOT EDIT! File to edit: 04A_cs_sentinel2.ipynb (unless otherwise specified).

__all__ = ['S2_BANDS', 'S2_BAND_REFS', 'S2_MEASUREMENTS', 'S2_METADATA', 's2_get_dt', 's2_get_spatial',
           's2_create_item', 's2_find_band_path', 'get_asset_spatial', 's2_add_assets2item', 's2_create_collection']

# Cell
import os
from glob import glob
import time
import numpy as np
from datetime import datetime
import json

import xmltodict
import pystac
from pystac import STAC_IO
from pystac.extensions.eo import Band
from pystac.extensions.sar import FrequencyBand, Polarization, ObservationDirection
import geopandas as gpd
import rasterio
# from shapely.geometry import Polygon

from .utils import s3_list_objects_paths
from .utils import pystac_setIO, create_uri, get_img_crs_and_bbox
from .extensions import add_custom_extensions
add_custom_extensions() # needed to extend pystac extensions without formally adding
pystac_setIO() # use bespoke own IO

# Cell
# common_names aligned to stac eo ext for inclusion at Asset-level - https://github.com/radiantearth/stac-spec/tree/master/extensions/eo
# scl added for scene classification
S2_BANDS = [Band.create(name='aot', description='TBD', common_name='aot'),
                  Band.create(name='coastal', description='TBD', common_name='coastal'),
                  Band.create(name='blue', description='TBD', common_name='blue'),
                  Band.create(name='green', description='TBD', common_name='green'),
                  Band.create(name='red', description='TBD', common_name='red'),
                  Band.create(name='nir', description='TBD', common_name='nir'),
                  Band.create(name='nir08', description='TBD', common_name='nir08'),
                  Band.create(name='nir09', description='TBD', common_name='nir09'),
                  Band.create(name='swir16', description='TBD', common_name='swir16'),
                  Band.create(name='swir22', description='TBDm', common_name='swir22'),
                  Band.create(name='scene_classification', description='TBDm', common_name='scene_classification'),
                  ]
# refs to help link file paths with bands when creating Assets
S2_BAND_REFS = {
    'AOT_10m': 'aot',
    'B01_60m': 'coastal',
    'B02_10m': 'blue',
    'B03_10m': 'green',
    'B04_10m': 'red',
    'B08_10m': 'nir',
    'B8A_20m': 'nir08',
    'B09_60m': 'nir09',
    'B11_20m': 'swir16',
    'B12_20m': 'swir22',
    'SCL_20m': 'scene_classification'
}
# measurements formatted for product_definition at Colelction-level and ODC indexing
S2_MEASUREMENTS = [{'name':'aot','units':'1','dtype':'uint16','nodata':0},
                   {'name':'coastal','units':'1','dtype':'uint16','nodata':0},
                   {'name':'blue','units':'1','dtype':'uint16','nodata':0},
                   {'name':'green','units':'1','dtype':'uint16','nodata':0},
                   {'name':'red','units':'1','dtype':'uint16','nodata':0},
                   {'name':'nir','units':'1','dtype':'uint16','nodata':0},
                   {'name':'nir08','units':'1','dtype':'uint16','nodata':0},
                   {'name':'nir09','units':'1','dtype':'uint16','nodata':0},
                   {'name':'swir16','units':'1','dtype':'uint16','nodata':0},
                   {'name':'swir22','units':'1','dtype':'uint16','nodata':0},
                   {'name':'scene_classification','units':'1','dtype':'uint8','nodata':0}]
# metadata for product_definition at Collection-level and ODC indexing
S2_METADATA = {
    "product":{"name":"sentinel_2"}
}

# Cell
def s2_get_dt(item_name):
    """Get time """
    return datetime.strptime(''.join([item_name.split('_')[2][:8],item_name.split('_')[2][9:]]), '%Y%m%d%H%M%S')

# Cell
def s2_get_spatial(img_uri):
    bbox, g, epsg = get_img_crs_and_bbox(img_uri) # g not valid mask, only bbox geometry...
    epsg_code = f"EPSG:{epsg.to_dict()['init'][5:]}"
    geom = json.loads(gpd.GeoSeries([g], crs=epsg_code).to_crs('EPSG:4326').to_json())['features'][0]['geometry']
    return bbox, geom, epsg_code

# Cell
def s2_create_item(item_name, item_obj_paths):

    # assume first item img asset rep of spatial
    bbox, geom, epsg = s2_get_spatial(create_uri([i for i in item_obj_paths if i.endswith('.tif')][0]))

    # core
    item = pystac.Item(id=item_name,
                      datetime=s2_get_dt(item_name),
                      geometry=geom,
                      bbox=bbox,
                      properties={})

    # extensions
    item.ext.enable('projection')
    item.ext.projection.epsg = int(epsg[5:])

    item.ext.enable('eo')
    item.ext.eo.cloud_cover = 0.0    # need to get from meta

    item.common_metadata.gsd = 10    # nominal asset resolution
    item.common_metadata.platform = 'sentinel_2'    # should diff S2 AvB?
    item.common_metadata.instruments = ['msi']
    item.common_metadata.constellation = 'sentinel_2'

    return item

# Cell
def s2_find_band_path(band_ref, item_obj_paths):
    matched_paths = [ o for o in item_obj_paths if (band_ref in o) ]
    if len(matched_paths) > 1:
        raise Exception(f"Found too many matches: {matched_paths}")
#     elif len(matched_paths) == 0:    # should probs add smth for when no asset is found (i.e. to help odc index)...
#         raise Warning(f"")
    return matched_paths[0]

# Cell
def get_asset_spatial(img_uri):
    with rasterio.open(img_uri) as ds:
        return list(ds.shape), list(ds.transform)

# Cell
def s2_add_assets2item(item, item_obj_paths):
    for b_ref in S2_BAND_REFS:
        band = [ b for b in S2_BANDS if b.name == S2_BAND_REFS[b_ref] ][0]

        band_path = s2_find_band_path(b_ref, item_obj_paths)
        band_url = create_uri(band_path)

        asset = pystac.Asset(href=band_url,
                             media_type=pystac.MediaType.COG)

        proj_shp, proj_tran = get_asset_spatial(band_url)

        item.ext.projection.set_transform(proj_tran, asset)
        item.ext.projection.set_shape(proj_shp, asset)
        item.ext.eo.set_bands([band], asset)

        item.add_asset(band.name, asset)

    return item

# Cell
def s2_create_collection(s2_dir, bucket='public-eo-data', n=None):

    collection_id = 'sentinel-2'
    collection_title = 'Copernicus Sentinel-2 datasets'
    collection_description = '''### Sentinel-2 Datasets

    A collection of Sentinel-2 datasets. Obtained from Copernicus Hub and Google Cloud and preparred by Catapult.
    '''

    # initially arbitrary as updated later
    spatial_extent = pystac.SpatialExtent([[-7.57216793459, 49.959999905, 1.68153079591, 58.6350001085]])
    temporal_extent = pystac.TemporalExtent([[datetime(2011, 12, 16), None]])
    collection_extent = pystac.Extent(spatial_extent, temporal_extent)

    collection = pystac.Collection(id=collection_id,
                                   title=collection_title,
                                   description=collection_description,
                                   extent=collection_extent,
#                                    product_definition={})
                                   properties={})

    collection.providers = [
        pystac.Provider(name='European Space Agency', roles=['producer'], url='https://www.esa.int/'),
        pystac.Provider(name='European Space Agency', roles=['licensor'], url='https://www.esa.int/'),
        pystac.Provider(name='Satellite Applications Catapult', roles=['processor'], url='https://sa.catapult.org.uk/'),
        pystac.Provider(name='Satellite Applications Catapult', roles=['host'], url='https://sa.catapult.org.uk/')
    ]

    collection.ext.enable('product_definition')
    collection.ext.product_definition.metadata_type = "eo3"
    collection.ext.product_definition.metadata = S2_METADATA
    collection.ext.product_definition.measurements = S2_MEASUREMENTS

    obj_paths_list = s3_list_objects_paths(bucket, s2_dir)
    item_names = list(np.unique([ i.split('/')[-2] for i in obj_paths_list ]))

    for item_name in item_names[:n]:
#         print(item_name)
        item_obj_paths = [ i for i in obj_paths_list if item_name in i]

        item = s2_create_item(item_name, item_obj_paths)
        item = s2_add_assets2item(item, item_obj_paths)

        collection.add_item(item)

    collection.update_extent_from_items()

    return collection
